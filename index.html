<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ретро-Ралли 80-х: Гонки с трафиком и поворотами</title>
    <style>
        /* Основные стили для страницы */
        body {
            margin: 0;
            overflow: hidden; /* Скрываем полосы прокрутки */
            background-color: #1a1a2e; /* Темно-синий фон космоса/ночи */
            font-family: 'Space Mono', monospace;
            color: #00ffcc;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            flex-direction: column; /* Для размещения кнопок под канвасом */
        }

        /* Импорт шрифта Google Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap');

        /* Стили для холста Three.js */
        canvas {
            display: block; /* Убираем лишние отступы */
            width: 100vw; /* Холст на всю ширину окна */
            height: calc(100vh - 80px); /* Высота холста минус высота кнопок */
        }

        /* Контейнер для инструкций */
        .instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 8px;
            color: #00ffcc;
            font-size: 0.9em;
            text-align: center;
            border: 1px solid #00ffcc;
            box-shadow: 0 0 10px #00ffcc;
            z-index: 10; /* Поверх канваса */
        }

        /* Стили для контейнера кнопок */
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 10;
        }

        /* Стили для кнопок управления */
        .control-button {
            background-color: #00b386; /* Зеленовато-бирюзовый */
            color: #1a1a2e;
            border: 2px solid #00ffcc;
            padding: 15px 30px;
            font-family: 'Space Mono', monospace;
            font-size: 1.2em;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 15px #00ffcc, 0 0 5px #00ffcc inset;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }

        .control-button:hover {
            background-color: #00ffcc;
            box-shadow: 0 0 25px #00ffcc, 0 0 10px #00ffcc inset;
        }

        .control-button:active {
            background-color: #00e6b3;
            box-shadow: 0 0 10px #00ffcc inset;
        }

        /* Стили для блока спидометра */
        .speedometer {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            color: #00ffcc;
            font-family: 'Space Mono', monospace;
            font-size: 1.5em;
            text-align: right;
            border: 1px solid #00ffcc;
            box-shadow: 0 0 10px #00ffcc;
            z-index: 10;
        }

        .speed-value {
            font-weight: bold;
            color: #ffcc00; /* Желтый для значения скорости */
        }
    </style>
</head>
<body>
    <!-- Инструкции для пользователя -->
    <div class="instructions">
        Используйте мышь, чтобы вращать камеру. Нажимайте и удерживайте кнопки "Вперёд", "Назад", "Влево", "Вправо" для движения.
    </div>

    <!-- Контейнер для кнопок управления -->
    <div class="controls">
        <button id="leftButton" class="control-button">Влево</button>
        <button id="forwardButton" class="control-button">Вперёд</button>
        <button id="backwardButton" class="control-button">Назад</button>
        <button id="rightButton" class="control-button">Вправо</button>
    </div>

    <!-- Блок спидометра -->
    <div class="speedometer">
        Скорость: <span id="speedDisplay" class="speed-value">0</span> км/ч
    </div>

    <!-- Подключаем библиотеку Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, car, road, leftNeon, rightNeon;
        let isDragging = false;
        let previousMousePosition = {
            x: 0,
            y: 0
        };

        // Переменные для управления движением автомобиля
        let carSpeed = 0;
        const acceleration = 0.05; // Скорость ускорения
        const deceleration = 0.03; // Скорость замедления при отпускании кнопок
        const maxSpeed = 1.5; // Максимальная скорость вперед
        const maxReverseSpeed = -0.5; // Максимальная скорость назад
        const speedConversionFactor = 100; // Коэффициент для перевода скорости в км/ч

        // Флаги для проверки нажатия кнопок
        let isForwardPressed = false;
        let isBackwardPressed = false;
        let isLeftPressed = false;
        let isRightPressed = false;

        // Переменные для поворота
        const turnRate = 0.03; // Скорость поворота
        const maxTurnAngle = Math.PI / 4; // Максимальный угол поворота (45 градусов в радианах)
        const lateralMoveSpeed = 0.1; // Скорость бокового перемещения при повороте
        const roadWidthLimit = 4.0; // Предел по X-координате для машины на дороге

        // Массив для хранения встречных машин
        const trafficCars = [];
        const trafficSpeed = 0.8; // Скорость встречных машин
        let lastTrafficSpawnTime = 0;
        const trafficSpawnInterval = 2000; // Интервал появления встречных машин (мс)

        // Инициализация сцены
        function init() {
            try {
                renderer = new THREE.WebGLRenderer({ antialias: true }); // Включаем сглаживание
                renderer.setSize(window.innerWidth, window.innerHeight - 80); // Устанавливаем размер рендерера
                document.body.insertBefore(renderer.domElement, document.querySelector('.controls')); // Добавляем холст перед кнопками
                console.log('WebGLRenderer успешно инициализирован.');
            } catch (e) {
                console.error("Ошибка при создании контекста WebGL:", e);
                document.body.innerHTML = '<div style="color: red; text-align: center; margin-top: 50px;">Не удалось инициализировать WebGL. Ваш браузер или устройство могут не поддерживать его.</div>';
                return; // Прекращаем инициализацию, если WebGL не работает
            }

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); // Темно-синий фон

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / (window.innerHeight - 80), 0.1, 1000);
            camera.position.set(0, 5, 15);
            camera.lookAt(new THREE.Vector3(0, 0, 0));

            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);

            createCar();
            createRoad();
            createNeonLines();

            addMouseControls();
            addControlButtons(); // Добавлены новые кнопки
            addKeyboardControls(); // Добавлены элементы управления с клавиатуры для удобства

            window.addEventListener('resize', onWindowResize, false);

            animate(); // Запускаем анимационный цикл
        }

        // Функция для создания автомобиля
        function createCar() {
            car = new THREE.Group();
            scene.add(car);

            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xff00ff, flatShading: true });
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, flatShading: true });

            const mainBodyGeometry = new THREE.BoxGeometry(3, 1, 5);
            const mainBody = new THREE.Mesh(mainBodyGeometry, bodyMaterial);
            mainBody.position.y = 0.5;
            car.add(mainBody);

            const cabinGeometry = new THREE.BoxGeometry(2.5, 0.8, 2.5);
            const cabin = new THREE.Mesh(cabinGeometry, bodyMaterial);
            cabin.position.set(0, 1.3, -0.5);
            car.add(cabin);

            const wheelGeometry = new THREE.CylinderGeometry(0.7, 0.7, 0.5, 8);
            wheelGeometry.rotateX(Math.PI / 2);

            const wheelPositions = [
                { x: -1.6, y: 0.2, z: 1.8 },
                { x: 1.6, y: 0.2, z: 1.8 },
                { x: -1.6, y: 0.2, z: -1.8 },
                { x: 1.6, y: 0.2, z: -1.8 }
            ];

            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos.x, pos.y, pos.z);
                car.add(wheel);
            });

            car.position.y = 0.1;
        }

        // Функция для создания встречной машины
        function createTrafficCar() {
            const trafficCar = new THREE.Group();
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00]; // Разные цвета для трафика
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            const trafficBodyMaterial = new THREE.MeshStandardMaterial({ color: randomColor, flatShading: true });
            const trafficWheelMaterial = new THREE.MeshStandardMaterial({ color: 0x111111, flatShading: true });

            const bodyGeometry = new THREE.BoxGeometry(2.5, 1, 4); // Чуть меньше, чем машина игрока
            const body = new THREE.Mesh(bodyGeometry, trafficBodyMaterial);
            body.position.y = 0.5;
            trafficCar.add(body);

            const cabinGeometry = new THREE.BoxGeometry(2, 0.7, 2);
            const cabin = new THREE.Mesh(cabinGeometry, trafficBodyMaterial);
            cabin.position.set(0, 1.2, -0.5);
            trafficCar.add(cabin);

            const wheelGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 8);
            wheelGeometry.rotateX(Math.PI / 2);

            const wheelPositions = [
                { x: -1.2, y: 0.2, z: 1.5 },
                { x: 1.2, y: 0.2, z: 1.5 },
                { x: -1.2, y: 0.2, z: -1.5 },
                { x: 1.2, y: 0.2, z: -1.5 }
            ];

            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, trafficWheelMaterial);
                wheel.position.set(pos.x, pos.y, pos.z);
                trafficCar.add(wheel);
            });

            // Случайная позиция по X на дороге
            trafficCar.position.x = (Math.random() * roadWidthLimit * 2) - roadWidthLimit;
            trafficCar.position.y = 0.1;
            trafficCar.position.z = -150 - Math.random() * 50; // Появляется далеко впереди

            scene.add(trafficCar);
            trafficCars.push(trafficCar);
        }


        // Функция для создания дороги
        function createRoad() {
            const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, flatShading: true });
            const roadGeometry = new THREE.BoxGeometry(10, 0.1, 200);
            road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.position.y = -0.1;
            road.position.z = -100;
            scene.add(road);

            const stripeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const stripeGeometry = new THREE.BoxGeometry(0.2, 0.11, 2);
            for (let i = -90; i < 90; i += 5) {
                const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                stripe.position.set(0, 0, i);
                road.add(stripe);
            }
        }

        // Функция для создания неоновых линий по бокам дороги
        function createNeonLines() {
            const neonMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 1.5 });
            const neonGeometry = new THREE.BoxGeometry(0.2, 0.2, 200);

            leftNeon = new THREE.Mesh(neonGeometry, neonMaterial);
            leftNeon.position.set(-4.5, 0, -100);
            scene.add(leftNeon);

            rightNeon = new THREE.Mesh(neonGeometry, neonMaterial);
            rightNeon.position.set(4.5, 0, -100);
            scene.add(rightNeon);
        }

        // Обработчики событий мыши для вращения камеры
        function addMouseControls() {
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
        }

        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function onMouseUp(event) {
            isDragging = false;
        }

        function onMouseMove(event) {
            if (!isDragging) return;

            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            const rotationSpeed = 0.005;
            const distance = camera.position.distanceTo(car.position);

            camera.position.x -= deltaX * rotationSpeed * distance;
            camera.position.y += deltaY * rotationSpeed * distance;

            camera.position.y = Math.max(1, Math.min(20, camera.position.y));

            camera.lookAt(car.position);
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        // Добавление обработчиков событий для кнопок управления (на экране)
        function addControlButtons() {
            const forwardButton = document.getElementById('forwardButton');
            const backwardButton = document.getElementById('backwardButton');
            const leftButton = document.getElementById('leftButton');
            const rightButton = document.getElementById('rightButton');

            forwardButton.addEventListener('mousedown', () => { isForwardPressed = true; });
            forwardButton.addEventListener('mouseup', () => { isForwardPressed = false; });
            forwardButton.addEventListener('touchstart', (e) => { e.preventDefault(); isForwardPressed = true; });
            forwardButton.addEventListener('touchend', () => { isForwardPressed = false; });

            backwardButton.addEventListener('mousedown', () => { isBackwardPressed = true; });
            backwardButton.addEventListener('mouseup', () => { isBackwardPressed = false; });
            backwardButton.addEventListener('touchstart', (e) => { e.preventDefault(); isBackwardPressed = true; });
            backwardButton.addEventListener('touchend', () => { isBackwardPressed = false; });

            leftButton.addEventListener('mousedown', () => { isLeftPressed = true; });
            leftButton.addEventListener('mouseup', () => { isLeftPressed = false; });
            leftButton.addEventListener('touchstart', (e) => { e.preventDefault(); isLeftPressed = true; });
            leftButton.addEventListener('touchend', () => { isLeftPressed = false; });

            rightButton.addEventListener('mousedown', () => { isRightPressed = true; });
            rightButton.addEventListener('mouseup', () => { isRightPressed = false; });
            rightButton.addEventListener('touchstart', (e) => { e.preventDefault(); isRightPressed = true; });
            rightButton.addEventListener('touchend', () => { isRightPressed = false; });
        }

        // Добавление обработчиков событий для клавиатуры (для удобства тестирования)
        function addKeyboardControls() {
            document.addEventListener('keydown', (event) => {
                switch (event.key) {
                    case 'ArrowUp':
                    case 'w':
                        isForwardPressed = true;
                        break;
                    case 'ArrowDown':
                    case 's':
                        isBackwardPressed = true;
                        break;
                    case 'ArrowLeft':
                    case 'a':
                        isLeftPressed = true;
                        break;
                    case 'ArrowRight':
                    case 'd':
                        isRightPressed = true;
                        break;
                }
            });

            document.addEventListener('keyup', (event) => {
                switch (event.key) {
                    case 'ArrowUp':
                    case 'w':
                        isForwardPressed = false;
                        break;
                    case 'ArrowDown':
                    case 's':
                        isBackwardPressed = false;
                        break;
                    case 'ArrowLeft':
                    case 'a':
                        isLeftPressed = false;
                        break;
                    case 'ArrowRight':
                    case 'd':
                        isRightPressed = false;
                        break;
                }
            });
        }


        // Обработка изменения размера окна
        function onWindowResize() {
            camera.aspect = window.innerWidth / (window.innerHeight - 80);
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight - 80);
        }

        // Анимационный цикл
        function animate() {
            requestAnimationFrame(animate);

            // Применение ускорения/замедления
            if (isForwardPressed) {
                carSpeed = Math.min(maxSpeed, carSpeed + acceleration);
            } else if (isBackwardPressed) {
                carSpeed = Math.max(maxReverseSpeed, carSpeed - acceleration);
            } else {
                if (carSpeed > 0) {
                    carSpeed = Math.max(0, carSpeed - deceleration);
                } else if (carSpeed < 0) {
                    carSpeed = Math.min(0, carSpeed + deceleration);
                }
            }

            // Логика поворота автомобиля
            if (isLeftPressed) {
                car.rotation.y = Math.min(maxTurnAngle, car.rotation.y + turnRate);
                car.position.x = Math.max(-roadWidthLimit, car.position.x - lateralMoveSpeed);
            } else if (isRightPressed) {
                car.rotation.y = Math.max(-maxTurnAngle, car.rotation.y - turnRate);
                car.position.x = Math.min(roadWidthLimit, car.position.x + lateralMoveSpeed);
            } else {
                // Возвращение в прямое положение
                if (car.rotation.y > 0.01) {
                    car.rotation.y = Math.max(0, car.rotation.y - turnRate);
                } else if (car.rotation.y < -0.01) {
                    car.rotation.y = Math.min(0, car.rotation.y + turnRate);
                } else {
                    car.rotation.y = 0; // Сбрасываем до 0, если очень близко
                }
            }

            // Движение дороги и неоновых линий
            if (road && leftNeon && rightNeon && car) {
                road.position.z += carSpeed;
                leftNeon.position.z += carSpeed;
                rightNeon.position.z += carSpeed;

                // Бесконечная прокрутка дороги
                if (road.position.z > 50) {
                    road.position.z -= 100;
                } else if (road.position.z < -150) {
                    road.position.z += 100;
                }

                // Бесконечная прокрутка неоновых линий
                if (leftNeon.position.z > 50) {
                    leftNeon.position.z -= 100;
                } else if (leftNeon.position.z < -150) {
                    leftNeon.position.z += 100;
                }
                if (rightNeon.position.z > 50) {
                    rightNeon.position.z -= 100;
                } else if (rightNeon.position.z < -150) {
                    rightNeon.position.z += 100;
                }

                // Движение встречных машин
                const carsToRemove = [];
                trafficCars.forEach(trafficCar => {
                    trafficCar.position.z += carSpeed - trafficSpeed; // Движение относительно игрока
                    if (trafficCar.position.z > camera.position.z + 20) { // Если машина позади камеры
                        carsToRemove.push(trafficCar);
                    }
                });

                // Удаление машин, которые вышли за пределы видимости
                carsToRemove.forEach(trafficCar => {
                    scene.remove(trafficCar);
                    trafficCars.splice(trafficCars.indexOf(trafficCar), 1);
                });

                // Появление новых машин
                if (Date.now() - lastTrafficSpawnTime > trafficSpawnInterval && trafficCars.length < 5) { // Ограничиваем количество машин
                    createTrafficCar();
                    lastTrafficSpawnTime = Date.now();
                }


                // Обновление спидометра
                const currentSpeedKmh = Math.abs(carSpeed * speedConversionFactor).toFixed(0);
                document.getElementById('speedDisplay').textContent = currentSpeedKmh;

                // Камера всегда смотрит на автомобиль и следует за ним по X
                camera.position.x = car.position.x;
                camera.lookAt(car.position);

                renderer.render(scene, camera);
            } else {
                console.warn("Объекты Three.js не инициализированы. Пропуск кадра анимации.");
            }
        }

        // Запускаем инициализацию и анимацию после загрузки окна
        window.onload = init;
    </script>
</body>
</html>
